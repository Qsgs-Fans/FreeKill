神貂蝉
======

“本回合改为由你操控。” ——神貂蝉

封装
----

先画好靶子！想一下怎么定义函数才好！

- 你来操控别的角色
- 别的角色重新操控自己
- 你同时控制自己和别人
- 询问无懈
- 老朱然

考虑中：。...

.. code:: lua

   ServerPlayer:control(ServerPlayer)
   ServerPlayer:observe(ServerPlayer)

两函数差不多了吧。。。

这样一来，神貂蝉就是让被控者observe，然后自己去control；回合结束后，被控者开始control。

observe
-------

对机器人：无视。

对人：发送observe消息。但这个人依然处于room.players中，无论是Lua还是cpp。

只是这个人对应的cpp层面的ServerPlayer进旁观了而已。

control
-------

控制者：发送control消息。控制者多了个可以控制的角色，仅此而已。

如果已有控制者：发送dontcontrol消息，不准打架 而这个消息最终还是走到observe消息处理

客户端实现
----------

想好了怎么发消息那消息该怎么处理？

首先dontcontrol 把可控制者-1 没有可控了就进旁观呗

然后是control加一个受控者 要是旁观直接切视角

切视角
------

先给个dashboard向下滑出并淡出消失的动画

Lua 改变 Self

根据服务端的信息填充这个新Self的信息

dashboard手牌清空

dashboard填入新Self的新手牌

dashboard重新出现

根据新Self重新安排所有photo

由于不影响烧条 这个动画效果越快越好

一控多时同时询问
----------------

怎么办呢？问题的核心在于分属不同玩家的消息，却发送给了同一个人。这个可以通过在req/noti中堆个玩家id的参数搞定。但是然后呢？

一个很严重的问题就是目前对所有req的处理函数都是直接操作roomscene的元素的。实际上，这些元素对于每个被自己控制的player，都要单独有才行。

一个想法就是多创建room页面，模拟多开。但这个是做不到的，因为很多东西都依赖Self，而Self只有一个。所以就得在单页中解决这些问题。解决方案就是把那些跟req有关的分出去几个。

换句话说，捏几个元素出来表示各个player的状态，可能保存在Lua里面。当qml想要切换视角时，从Lua读取信息。

当某个人收到req时候，就切视角到他那里。所有人烧条打开。

或者也可以让req处理函数返回一个函数，切视角时执行之就行了。

也就是说 Room中元素还是那几个 只是随着视角改变他们的值也变 而改变视角会调用函数

其实可以考虑调用从Lua传来的cmdType和jsonData，然后就直接开函数了，更舒适。

延迟执行callback
-----------------

考虑在notifyUI的时候，如果当前视角对应的玩家id和这个消息的id不同，那么就暂存到一个消息队列中，等到切视角时候就都拿出来。如果某时候，就把队列清空。

主要还是只过滤request吧。doNotify不需要过滤，换个视角也知道发生啥了。

也没必要维护队列。就一个单独的值保存最近的command和data即可。

当视角发生切换时，如果这个人有cmd和data，就执行相应的cb。

当向服务器发回答复后，cmd和data就没有了。

notify时只对看着这名角色主视角的玩家发送。
