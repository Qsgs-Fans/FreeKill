拓展包ai文件写法：
按照包文件夹名+_ai，例如standard_cards是standard_cards_ai.lua，直接放在init.lua同位置下。

分辨敌我：
设置反值内值，同时设置技能和牌的身份值；例如杀的值为100，主公或跳身份的忠被杀时，来源反值+100，当一名角色反值大于50时，将识别为反贼；当跳反者杀反贼（或跳忠者杀主忠）时，他内值就+100，内值大于50的将被识别为内奸；当然，标记身份是以最高值开始标记身份，例如场上两名角色为400和300的最高反值，但是反贼只剩下一个，那么就只将400的标记为反贼，其余身份也是如此。优先针对虚弱，相同虚弱再优先仇恨。

要让身份值加给角色，就需要在使用技能或牌时接入ai接口，所以我在触发时机函数的最后加了接口，用于获取此时触发时机的数据，例如1号位杀2号位，此时触发了指定目标时机，就可以通过接口接入ai，然后让来源反值+100。但是N神不想这样增加接口，但我还不了解怎么通过其他方式同步获取使用技能或牌的数据......

空闲点ai出牌：
先定义阶段技或卡牌的优先度，然后获取角色所有可用的阶段技和卡牌，按照优先度进行排序，再进行for列表逐一检测是否可使用，可使用则检测是否有使用函数，有则执行使用函数；在使用函数里进行定义self.use_id和给self.use_tos添加角色id；然后系统检测有self.use_id则输出使用（如果是使用卡则self.use_id=卡id，阶段技是self.use_id=子卡表{})，同时可以给self.use_tos添加角色id做为牌或技能的目标，会同步输出。

请求ai使用牌：
包含请求无懈，请求桃，借刀请求杀等
请求无懈有正无懈和反无懈，系统根据生效锦囊牌名定位请求代码（之后可以增加来源和目标技能名来修正是否使用，例如要通过伤害锦囊卖血时，可以通过技能名阻止友方使用无懈），同时请求代码会带有正反无懈的参数，根据这个参数进行分类讨论，请求代码需定义self.use_id为将要使用的无懈id，当然也可以定义self.use_id=true，这样就会根据卡牌优先度选择第一个无懈使用。因为要区分正反无懈，我在room里的请求无懈时增加了fk.askNullification和fk.askNullificationData，前者用来区分正反无懈，后者记录要无懈的锦囊数据，因为直接获取使用数据，可能会是上个无懈的数据而不是最初锦囊的数据，当然我并不知道其他的识别正反无懈和获取源锦囊生效数据的方法，只能是手动增加记录的这个样子来实现.....

请求桃默认给友军使用，但是可以通过来源和目标的技能来修正来源是否要使用桃

剩下的请求牌根据提示信息名进行决策，兜底决策是套用空闲点出牌代码，所以说请求使用牌和空闲点使用牌的的函数是相通的，如果请求使用牌没有定义函数，就会调用空闲点使用牌的函数来兜底。

技能转化牌：
急救桃、倾国闪等
也是通过技能名定位转化代码，也需要定义self.use_id为技能子卡表{}就行，如果没有子卡就定义空表{}，如果不定义就表示不使用转化技。

请求ai打出牌：
杀响应决斗南蛮等
根据牌名或技能名来分别决策，同时优先以技能名决策（用于卖血技），兜底决策是默认不响应，因为有部分是技能请求响应，例如鬼才改判打出。响应牌依旧是将要响应的卡的id定义为self.use_id（懒得再定义个新参数）

请求ai弃置牌：
给每个牌名定义保留值，然后排序并优先弃置低保留值的牌。

请求ai发动技能：
直接按照技能名分别决策。
技能请求选择角色是给self.use_tos添加目标id，例如突袭
既请求选择角色又请求选择牌就再增加定义self.use_id为技能子卡表{}

请求ai选择角色区域牌：
按照提示信息名分别决策，同时设置兜底决策，对敌军优先选择其重要的牌。
依旧是定义self.use_id为技能子卡表{}，不论选择一张牌还是多张牌，都是将牌id添加到表然后定义给self.use_id。

请求ai选择选项：
按照提示信息名分别决策，同时兜底决策是随机选择。
这个就直接返回需要选择的选项就行。



